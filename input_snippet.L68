00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.04
Created On: 3/8/2016 12:23:06 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 
00000000                             3  * Written by : Kei C.
00000000                             4  * Date       : 3/1/2016
00000000                             5  * Description: Gets value of two addresses in hex format
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  START:
00001000  43F9 0000110A              9      LEA     WELCOME,A1 
00001006  103C 000E                 10      MOVE.B  #14,D0
0000100A  4E4F                      11      TRAP    #15 ; display welcome
0000100C  6000 0002                 12      BRA     INPUT_HANDLER
00001010                            13      
00001010                            14  INPUT_HANDLER:                  
00001010                            15  
00001010  43F9 00001129             16      LEA     PROMPTST,A1 
00001016  103C 000E                 17      MOVE.B  #14,D0
0000101A  4E4F                      18      TRAP    #15 ; display st address prompt
0000101C                            19      
0000101C  43F9 0000117A             20      LEA     ADDR_BUFFER,A1
00001022  103C 0002                 21      MOVE.B  #2,D0
00001026  4E4F                      22      TRAP    #15 ; read starting address as ascii. stores it in (A1) as a buffer. 
00001028                            23                  ; length gets stored in D1
00001028                            24      
00001028                            25      ; can check for invalid length first
00001028                            26      ; address must be between $0 and $FFFFFF (highest 6-digit) inclusive
00001028  B23C 0000                 27      CMP.B   #0,D1
0000102C  6F00 0078                 28      BLE     INVALID
00001030  B23C 0007                 29      CMP.B   #7,D1
00001034  6C00 0070                 30      BGE     INVALID
00001038                            31  
00001038                            32      
00001038                            33      ; temporarily store string length value in D2
00001038                            34      ; and store address in A2 (D1, A1 for use in LOOP later)
00001038  1401                      35      MOVE.B  D1,D2
0000103A  3449                      36      MOVEA.W A1,A2
0000103C                            37      ; check for invalid characters
0000103C  6000 0080                 38      BRA     CHECKLOOP
00001040                            39      
00001040                            40  CLEARED: ; address is valid so far
00001040  4280                      41      CLR.L   D0
00001042  6000 0092                 42      BRA     LOOP ; go to conversion loop
00001046                            43  
00001046                            44  ENDLOOP:    
00001046                            45      
00001046  4280                      46      CLR.L   D0
00001048                            47      
00001048  43F9 0000114A             48      LEA     PROMPTEND,A1 
0000104E  103C 000E                 49      MOVE.B  #14,D0
00001052  4E4F                      50      TRAP    #15 ; display end address prompt
00001054                            51      
00001054  43F9 0000117A             52      LEA     ADDR_BUFFER,A1
0000105A  103C 0002                 53      MOVE.B  #2,D0
0000105E  4E4F                      54      TRAP    #15 ; read starting address as ascii. stores it in (A1) as a buffer. 
00001060                            55                  ; length gets stored in D1
00001060                            56  
00001060                            57  
00001060                            58      ; can check for invalid length first
00001060                            59      ; address must be between $0 and $FFFFFF (highest 6-digit) inclusive
00001060  B23C 0000                 60      CMP.B   #0,D1
00001064  6F00 0040                 61      BLE     INVALID
00001068  B23C 0007                 62      CMP.B   #7,D1
0000106C  6C00 0038                 63      BGE     INVALID
00001070                            64  
00001070                            65      ; temporarily store string length value in D2
00001070                            66      ; and store address in A2 (D1, A1 for use in LOOP later)
00001070  1401                      67      MOVE.B  D1,D2
00001072  3449                      68      MOVEA.W A1,A2
00001074                            69      ; check for invalid characters
00001074  6000 0048                 70      BRA     CHECKLOOP
00001078                            71  
00001078                            72  SEND_ADDR: ; gets called after conversion loop. puts the address value in memory.
00001078                            73      
00001078                            74      ; now check for odd address
00001078  0800 0000                 75      BTST.L  #0,D0   ; checks if bit 0 of address is set, which indicates odd address
0000107C  6600 0028                 76      BNE     INVALID
00001080                            77      
00001080  B7FC 00000000             78      CMPA.L   #$00000000,A3 ; if A3 (soon to be the input address) is already filled,
00001086                            79                             ; go to SEND_END_ADDR instead 
00001086  6600 0006                 80      BNE     SEND_END_ADDR
0000108A  2640                      81      MOVEA.L  D0,A3
0000108C  60B8                      82      BRA ENDLOOP
0000108E                            83  SEND_END_ADDR:
0000108E  2840                      84      MOVEA.L D0,A4 ; A4 is ending address
00001090  B7CC                      85      CMPA.L  A4,A3
00001092  6E00 0012                 86      BGT     INVALID ; starting addr > ending addr
00001096  23CB 000011CA             87      MOVE.L  A3,START_ADDR 
0000109C  23CC 0000130A             88      MOVE.L  A4,END_ADDR
000010A2  6000 0060                 89      BRA END    
000010A6                            90      
000010A6                            91  INVALID:
000010A6  43F9 00001169             92      LEA     INVALID_MSG,A1
000010AC  103C 000E                 93      MOVE.B  #14,D0
000010B0  4E4F                      94      TRAP    #15 ; display error message
000010B2  B7FC 00000000             95      CMPA.L  #$00000000,A3
000010B8  668C                      96      BNE     ENDLOOP ; if 1st addr is already filled, goto second input loop
000010BA  6000 FF54                 97      BRA     INPUT_HANDLER ; go back to starting prompt
000010BE                            98      
000010BE                            99  CHECKLOOP: ; loop that checks for invalid characters in an address
000010BE  0C12 0047                100      CMPI.B  #$47,(A2) ; checks if character is over 'F'
000010C2  6CE2                     101      BGE     INVALID
000010C4  0C1A 002F                102      CMPI.B  #$2F,(A2)+ ; checks if character is under '0'
000010C8  6FDC                     103      BLE     INVALID
000010CA  5302                     104      SUBI.B  #1,D2
000010CC  0C02 0000                105      CMPI.B  #0,D2
000010D0  6700 FF6E                106      BEQ     CLEARED ; reached end of string, no errors
000010D4  60E8                     107      BRA     CHECKLOOP
000010D6                           108  LOOP: ; conversion loop
000010D6  0C11 0041                109      CMPI.B  #$41,(A1)
000010DA  6C00 0018                110      BGE     TEN_OR_HIGHER
000010DE  0C11 0039                111      CMPI.B  #$39,(A1)
000010E2  6F00 0018                112      BLE     NINE_OR_LESS
000010E6                           113  CONT:    
000010E6  8019                     114      OR.B    (A1)+,D0 ; add byte value to D0, move A1 to next byte
000010E8                           115  
000010E8  5301                     116      SUBI.B  #1,D1 ; decrement D1, which holds # of chars in input
000010EA  0C01 0000                117      CMPI.B  #0,D1 ; check if D1 reached 0. if so, end of iteration
000010EE  6788                     118      BEQ     SEND_ADDR
000010F0                           119      
000010F0  E980                     120      ASL.L   #4,D0 ; shift hex digit in D0 left
000010F2                           121      
000010F2  60E2                     122      BRA     LOOP 
000010F4                           123      
000010F4                           124  TEN_OR_HIGHER:
000010F4  0411 0037                125      SUB.B   #55,(A1)  ; get hex value for char, store in A1
000010F8  4EF8 10E6                126      JMP     CONT
000010FC                           127  NINE_OR_LESS:
000010FC  0411 0030                128      SUB.B   #48,(A1)  ; get hex value for number, store in A1
00001100  4EF8 10E6                129      JMP     CONT
00001104                           130      
00001104                           131  END:
00001104  103C 0009                132      MOVE.B  #9,D0
00001108  4E4F                     133      TRAP    #15
0000110A                           134      
0000110A  =0000000D                135  CR  EQU $0D
0000110A  =0000000A                136  LF  EQU $0A
0000110A                           137  
0000110A= 57 65 6C 63 6F 6D ...    138  WELCOME     DC.B    'Welcome to the disassembler!',CR,LF,0
00001129= 45 6E 74 65 72 20 ...    139  PROMPTST    DC.B    'Enter starting address in hex:',CR,LF,0
0000114A= 45 6E 74 65 72 20 ...    140  PROMPTEND   DC.B    'Enter ending address in hex:',CR,LF,0
00001169= 49 6E 76 61 6C 69 ...    141  INVALID_MSG DC.B    'Invalid input!',CR,LF,0
0000117A                           142  ADDR_BUFFER DS.B    80
000011CA                           143  START_ADDR  DS.L    80
0000130A                           144  END_ADDR    DS.L    80
0000144A                           145  
0000144A                           146      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDR_BUFFER         117A
CHECKLOOP           10BE
CLEARED             1040
CONT                10E6
CR                  D
END                 1104
ENDLOOP             1046
END_ADDR            130A
INPUT_HANDLER       1010
INVALID             10A6
INVALID_MSG         1169
LF                  A
LOOP                10D6
NINE_OR_LESS        10FC
PROMPTEND           114A
PROMPTST            1129
SEND_ADDR           1078
SEND_END_ADDR       108E
START               1000
START_ADDR          11CA
TEN_OR_HIGHER       10F4
WELCOME             110A
